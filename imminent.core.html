<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>imminent.core documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Imminent 0.1.0 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><a href="index.html"><span class="inner">Namespaces</span></a></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>imminent</span></div></div></li><li class="depth-2 branch current"><a href="imminent.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="imminent.executors.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>executors</span></div></a></li><li class="depth-2 branch"><a href="imminent.future.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>future</span></div></a></li><li class="depth-2 branch"><a href="imminent.protocols.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>protocols</span></div></a></li><li class="depth-2 branch"><a href="imminent.result.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>result</span></div></a></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>util</span></div></div></li><li class="depth-3 branch"><a href="imminent.util.applicative.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>applicative</span></div></a></li><li class="depth-3 branch"><a href="imminent.util.functor.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>functor</span></div></a></li><li class="depth-3 branch"><a href="imminent.util.monad.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>monad</span></div></a></li><li class="depth-3"><a href="imminent.util.namespaces.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>namespaces</span></div></a></li></ul></div><div class="sidebar" id="vars"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="imminent.core.html#var-.3C*.3E"><div class="inner"><span>&lt;*&gt;</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-alift"><div class="inner"><span>alift</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-Applicative"><div class="inner"><span>Applicative</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-blocking-future"><div class="inner"><span>blocking-future</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-blocking-future-call"><div class="inner"><span>blocking-future-call</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-const-future"><div class="inner"><span>const-future</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-curry"><div class="inner"><span>curry</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-dderef"><div class="inner"><span>dderef</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-failed-future"><div class="inner"><span>failed-future</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-failure"><div class="inner"><span>failure</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-filter-future"><div class="inner"><span>filter-future</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-flatmap"><div class="inner"><span>flatmap</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-from-try"><div class="inner"><span>from-try</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-Functor"><div class="inner"><span>Functor</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-future"><div class="inner"><span>future</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-future-call"><div class="inner"><span>future-call</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-IAwaitable"><div class="inner"><span>IAwaitable</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-IFuture"><div class="inner"><span>IFuture</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-IPromise"><div class="inner"><span>IPromise</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-IReturn"><div class="inner"><span>IReturn</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-m-ctx"><div class="inner"><span>m-ctx</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-map"><div class="inner"><span>map</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-map-future"><div class="inner"><span>map-future</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-mdo"><div class="inner"><span>mdo</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-Monad"><div class="inner"><span>Monad</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-promise"><div class="inner"><span>promise</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-reduce"><div class="inner"><span>reduce</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-sequence"><div class="inner"><span>sequence</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-success"><div class="inner"><span>success</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-try*"><div class="inner"><span>try*</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-try-future"><div class="inner"><span>try-future</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h2 class="anchor" id="top">imminent.core</h2><div class="doc"><pre class="plaintext">Convenience namespace. Require this instead of the individual namespaces to prevent
large namespace declarations. Its use is entirely optional.</pre></div><div class="public anchor" id="var-.3C*.3E"><h3>&lt;*&gt;</h3><div class="usage"><code>(&lt;*&gt; af)</code><code>(&lt;*&gt; af av)</code><code>(&lt;*&gt; af av &amp; avs)</code></div><div class="doc"><pre class="plaintext">Performs a Haskell-style left-associative fapply
on its arguments. (&lt;*&gt; f g h) is equivalent to
(fapply (fapply f g) h). It always uses a two-argument fapply.

If only two arguments are supplied, it is equivalent to fapply.
When called with one argument, creates a function
that can accept the rest of the arguments and apply &lt;*&gt;.
</pre></div></div><div class="public anchor" id="var-alift"><h3>alift</h3><div class="usage"><code>(alift f)</code></div><div class="doc"><pre class="plaintext">Lifts a n-ary function `f` into a applicative context
</pre></div></div><div class="public anchor" id="var-Applicative"><h3>Applicative</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Applicative (applicative functor) is an abstraction for a
context (box, container, computation) along with the abiliity
to apply function(s) contained in the same type of context to
all the things inside that context. Every Applicative should
also implement Functor, although it can not be automatically
forced by Clojure protocols.

A typical example is a clojure sequence, wich is a container
of elements, with the ability to apply all the functions
contained in another sequence to each of the elements,
wich produces a new sequence of elements transformed by
all the functions.

You create a new applicative functor type by extending
the Applicative protocol and implementing pure and fapply
methods, while observing applicative functor laws:

1. (fapply (pure x f) x) =&gt; (fmap f x)

2. Identity Law: (fapply (pure x identity) x) =&gt; x

3. Composition Law:
   (fapply (fapply (fapply (pure x (curry comp)) u) v) x)
   =&gt; (fapply u (fapply v x))

4. Homomorphism Law: (fapply (pure a f) (pure a x)) =&gt; (f x)

5. Interchange Law:
   (fapply u (pure a y)) =&gt; (fapply (pure a #(% y)) u)

Fluokitten&apos;s test library contains macros that generate
tests for applicative functor laws.

The pure and fapply methods are not intended to be used
directly by the caller, although you should use them directly
from the implementation of this protocol if needed from
other methods.
</pre></div></div><div class="public anchor" id="var-blocking-future"><h3>blocking-future</h3><h4 class="type">macro</h4><div class="usage"><code>(blocking-future &amp; body)</code></div><div class="doc"><pre class="plaintext">Dispatches `body` on a separate thread and returns a future that will eventually contain the result. `body` may block.
See `future-call`</pre></div></div><div class="public anchor" id="var-blocking-future-call"><h3>blocking-future-call</h3><div class="usage"><code>(blocking-future-call task)</code></div><div class="doc"><pre class="plaintext">Dispatches `task` on a separate thread and returns a future that will eventually contain the result of `task`.
`task` may block.</pre></div></div><div class="public anchor" id="var-const-future"><h3>const-future</h3><div class="usage"><code>(const-future v)</code></div><div class="doc"><pre class="plaintext">Creates a new future and immediately completes it successfully with `v`
</pre></div></div><div class="public anchor" id="var-curry"><h3>curry</h3><div class="usage"><code>(curry f)</code><code>(curry f arity)</code></div><div class="doc"><pre class="plaintext">Creates an automatically curried version of the function f.
If arity is supplied, the function will be automatically
curried when called with less arguments. If arity is not
supplied, the default arity will depend on the arity of f.
arity defaults to 2 if f can support it, otherwise it is
1.

---- Example: currying +
(((curry +) 3) 5)
=&gt; 8

((((curry + 3) 3) 5) 7)
=&gt; 15

((curry +) 3 5 7)
=&gt; 15
</pre></div></div><div class="public anchor" id="var-dderef"><h3>dderef</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Same as (deref (deref x))
</pre></div></div><div class="public anchor" id="var-failed-future"><h3>failed-future</h3><div class="usage"><code>(failed-future e)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-failure"><h3>failure</h3><div class="usage"><code>(failure v)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-filter-future"><h3>filter-future</h3><div class="usage"></div><div class="doc"><pre class="plaintext">`pred?` needs to return a Future that yields a boolean. Returns a Future which yields a future containing all Futures which match `pred?`
</pre></div></div><div class="public anchor" id="var-flatmap"><h3>flatmap</h3><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-from-try"><h3>from-try</h3><div class="usage"><code>(from-try f)</code></div><div class="doc"><pre class="plaintext">Creates a future from a function `f`. See `try*`
</pre></div></div><div class="public anchor" id="var-Functor"><h3>Functor</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Functor is an abstraction for a context (box, container,
computation) along with the abiliity to apply a function
to all the things inside that context. A typical example
is a clojure sequence, wich is a container of elements,
with the ability to apply a function to each of the elements,
wich produces a new sequence of elements transformed by
that function.

You create a new functor type by extending the Functor
protocol and implementing fmap method, while observing
functor laws:

1. (fmap identity) =&gt; identity ,
   that is (fmap identity x) =&gt; (identity x)

2. (fmap (comp f g)) =&gt; (fmap f (fmap g))
   or, when applied to a concrete functor
   (fmap (comp f g) x) =&gt; (fmap f (fmap g x))

(please note that core&apos;s fmap that has a different
order of arguments has been used in these examples,
as it would be used by clients)

Fluokitten&apos;s test library contains macros that generate
tests for functor laws.

The fmap method is not intended to be used directly by
the caller, although you should use it directly from
the implementation of this protocol if needed from
other methods.
</pre></div></div><div class="public anchor" id="var-future"><h3>future</h3><h4 class="type">macro</h4><div class="usage"><code>(future &amp; body)</code></div><div class="doc"><pre class="plaintext">Dispatches `body` on a separate thread and returns a future that will eventually contain the result. `body` must be free of side effects.
See `future-call`</pre></div></div><div class="public anchor" id="var-future-call"><h3>future-call</h3><div class="usage"><code>(future-call task)</code></div><div class="doc"><pre class="plaintext">Dispatches `task` on a separate thread and returns a future that will eventually contain the result of `task`.
`task` must be free of side effects.</pre></div></div><div class="public anchor" id="var-IAwaitable"><h3>IAwaitable</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-IFuture"><h3>IFuture</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-IPromise"><h3>IPromise</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-IReturn"><h3>IReturn</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-m-ctx"><h3>m-ctx</h3><div class="usage"></div><div class="doc"><pre class="plaintext">A simple, &apos;empty&apos; future instance that can be used as a monad context to combinators that require one.
</pre></div></div><div class="public anchor" id="var-map"><h3>map</h3><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-map-future"><h3>map-future</h3><div class="usage"></div><div class="doc"><pre class="plaintext">`f` needs to return a future. Maps `f` over `vs` and sequences all resulting futures. See `sequence`
</pre></div></div><div class="public anchor" id="var-mdo"><h3>mdo</h3><h4 class="type">macro</h4><div class="usage"><code>(mdo bindings body)</code></div><div class="doc"><pre class="plaintext">A syntactic sugar for gluing together chained bind calls.
The structure of mdo is similar to the structure of let.

bindings should be a vector of symbol - expression pairs
in the form [sym1 exp1 sym2 exp2 ...].
while the body should be an expression that uses these
symbols. Body is not wrapped in an implicit do block, so
if multiple forms are needed in the block, they have to
be explicitly wrapped with do.

If the bindings vector is empty, there are no bindings and
no bind function calls, mdo simply evaluates body in that
case.

(mdo [x some-monadic-value
      y some-other-monadic-value]
  some-expression)

expands to:

(bind some-monadic-value
      (fn [x]
        (bind some-other-monadic-value
              (fn [y]
                some-expression))))))

bind maintains an implicit context, so mdo too supports
functions that depend on it, such are return and unit.

---- Example:
(mdo [a [1 2]
      b [4 5]
      c [7]]
  (return (* a b c)))

=&gt; [28 35 56 70]
</pre></div></div><div class="public anchor" id="var-Monad"><h3>Monad</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Monad is an abstraction for a context (box, container,
computation) along with the ability to apply a function
that accepts the value without the context and produces
the result in a context. The resulting context may be
different than the starting context. While the main idea
with functors and applicatives is modifying the values
inside the context, monad is more oriented towards modifying
the context.  Every Monad should also implement
Applicative and Functor protocols, although this can not be
automatically forced by Clojure compiler.

You create a new monad type by extending the Monad protocol
and implementing bind and join methods, while observing
monad laws:

1. Left Identity Law: (bind (pure m x) f) =&gt; (g x)

2. Right Identity Law: (bind m (pure m)) =&gt; m

3. Associativity Law:
   (bind (bind m f) g) =&gt; (bind m (fn [x] (bind (f x) g)

Fluokitten&apos;s test library contains macros that generate
tests for monad laws.

The bind and join methods are not intended to be used
directly by the caller, although you should use them directly
from the implementation of this protocol if needed from
other methods.
</pre></div></div><div class="public anchor" id="var-promise"><h3>promise</h3><div class="usage"><code>(promise)</code></div><div class="doc"><pre class="plaintext">Creates a new, unresolved promise.
</pre></div></div><div class="public anchor" id="var-reduce"><h3>reduce</h3><div class="usage"><code>(reduce f seed ms)</code></div><div class="doc"><pre class="plaintext">Returns a Future containing a list of the results yielded by all futures in `ms` further reduced using `f` and `seed`. See `sequence` and `map`
</pre></div></div><div class="public anchor" id="var-sequence"><h3>sequence</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Given a list of futures, returns a future that will eventually contain a list of the results yielded by all futures. If any future fails, returns a Future representing that failure
</pre></div></div><div class="public anchor" id="var-success"><h3>success</h3><div class="usage"><code>(success v)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-try*"><h3>try*</h3><div class="usage"><code>(try* f)</code></div><div class="doc"><pre class="plaintext">Wraps `f` in a try/catch. Returns the result of `f` in a `Success` type if successful. Returns a `Failure` containing the exception otherwise.
</pre></div></div><div class="public anchor" id="var-try-future"><h3>try-future</h3><h4 class="type">macro</h4><div class="usage"><code>(try-future &amp; body)</code></div><div class="doc"><pre class="plaintext">Wraps body in a try/catch. If an exception is thrown, returns a Future which yields a Failure containg the exception.
</pre></div></div></div></body></html>