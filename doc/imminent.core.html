<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>imminent.core documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Imminent 0.1.0 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><a href="index.html"><span class="inner">Namespaces</span></a></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>imminent</span></div></div></li><li class="depth-2 branch current"><a href="imminent.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="imminent.executors.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>executors</span></div></a></li><li class="depth-2 branch"><a href="imminent.future.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>future</span></div></a></li><li class="depth-2 branch"><a href="imminent.protocols.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>protocols</span></div></a></li><li class="depth-2 branch"><a href="imminent.result.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>result</span></div></a></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>util</span></div></div></li><li class="depth-3 branch"><a href="imminent.util.monad.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>monad</span></div></a></li><li class="depth-3"><a href="imminent.util.namespaces.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>namespaces</span></div></a></li></ul></div><div class="sidebar" id="vars"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="imminent.core.html#var-Applicative"><div class="inner"><span>Applicative</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-const-future"><div class="inner"><span>const-future</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-failed-future"><div class="inner"><span>failed-future</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-failure"><div class="inner"><span>failure</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-filter-future"><div class="inner"><span>filter-future</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-flatmap"><div class="inner"><span>flatmap</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-from-try"><div class="inner"><span>from-try</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-Functor"><div class="inner"><span>Functor</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-future"><div class="inner"><span>future</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-future-call"><div class="inner"><span>future-call</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-IAwaitable"><div class="inner"><span>IAwaitable</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-IFuture"><div class="inner"><span>IFuture</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-IPromise"><div class="inner"><span>IPromise</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-IReturn"><div class="inner"><span>IReturn</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-map-future"><div class="inner"><span>map-future</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-Monad"><div class="inner"><span>Monad</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-promise"><div class="inner"><span>promise</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-reduce"><div class="inner"><span>reduce</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-sequence"><div class="inner"><span>sequence</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-success"><div class="inner"><span>success</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-try*"><div class="inner"><span>try*</span></div></a></li><li class="depth-1"><a href="imminent.core.html#var-try-future"><div class="inner"><span>try-future</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h2 class="anchor" id="top">imminent.core</h2><div class="doc"><pre class="plaintext">Convenience namespace. Require this instead of the individual namespaces to prevent
large namespace declarations. Its use is entirely optional.</pre></div><div class="public anchor" id="var-Applicative"><h3>Applicative</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Applicative (applicative functor) is an abstraction for a
context (box, container, computation) along with the abiliity
to apply function(s) contained in the same type of context to
all the things inside that context. Every Applicative should
also implement Functor, although it can not be automatically
forced by Clojure protocols.

A typical example is a clojure sequence, wich is a container
of elements, with the ability to apply all the functions
contained in another sequence to each of the elements,
wich produces a new sequence of elements transformed by
all the functions.

You create a new applicative functor type by extending
the Applicative protocol and implementing pure and fapply
methods, while observing applicative functor laws:

1. (fapply (pure x f) x) =&gt; (fmap f x)

2. Identity Law: (fapply (pure x identity) x) =&gt; x

3. Composition Law:
   (fapply (fapply (fapply (pure x (curry comp)) u) v) x)
   =&gt; (fapply u (fapply v x))

4. Homomorphism Law: (fapply (pure a f) (pure a x)) =&gt; (f x)

5. Interchange Law:
   (fapply u (pure a y)) =&gt; (fapply (pure a #(% y)) u)

Fluokitten&apos;s test library contains macros that generate
tests for applicative functor laws.

The pure and fapply methods are not intended to be used
directly by the caller, although you should use them directly
from the implementation of this protocol if needed from
other methods.
</pre></div></div><div class="public anchor" id="var-const-future"><h3>const-future</h3><div class="usage"><code>(const-future v)</code></div><div class="doc"><pre class="plaintext">Creates a new future and immediately completes it successfully with `v`
</pre></div></div><div class="public anchor" id="var-failed-future"><h3>failed-future</h3><div class="usage"><code>(failed-future e)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-failure"><h3>failure</h3><div class="usage"><code>(failure v)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-filter-future"><h3>filter-future</h3><div class="usage"></div><div class="doc"><pre class="plaintext">`pred?` needs to return a Future that yields a boolean. Returns a Future which yields a future containing all Futures which match `pred?`
</pre></div></div><div class="public anchor" id="var-flatmap"><h3>flatmap</h3><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-from-try"><h3>from-try</h3><div class="usage"><code>(from-try f)</code></div><div class="doc"><pre class="plaintext">Creates a future from a function `f`. See `try*`
</pre></div></div><div class="public anchor" id="var-Functor"><h3>Functor</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Functor is an abstraction for a context (box, container,
computation) along with the abiliity to apply a function
to all the things inside that context. A typical example
is a clojure sequence, wich is a container of elements,
with the ability to apply a function to each of the elements,
wich produces a new sequence of elements transformed by
that function.

You create a new functor type by extending the Functor
protocol and implementing fmap method, while observing
functor laws:

1. (fmap identity) =&gt; identity ,
   that is (fmap identity x) =&gt; (identity x)

2. (fmap (comp f g)) =&gt; (fmap f (fmap g))
   or, when applied to a concrete functor
   (fmap (comp f g) x) =&gt; (fmap f (fmap g x))

(please note that core&apos;s fmap that has a different
order of arguments has been used in these examples,
as it would be used by clients)

Fluokitten&apos;s test library contains macros that generate
tests for functor laws.

The fmap method is not intended to be used directly by
the caller, although you should use it directly from
the implementation of this protocol if needed from
other methods.
</pre></div></div><div class="public anchor" id="var-future"><h3>future</h3><h4 class="type">macro</h4><div class="usage"><code>(future &amp; body)</code></div><div class="doc"><pre class="plaintext">Dispatches `body` on a separate thread and returns a future that will eventually contain the result. See `future-call`
</pre></div></div><div class="public anchor" id="var-future-call"><h3>future-call</h3><div class="usage"><code>(future-call task)</code></div><div class="doc"><pre class="plaintext">Dispatches `task` on a separate thread and returns a future that will eventually contain the result of `task`
</pre></div></div><div class="public anchor" id="var-IAwaitable"><h3>IAwaitable</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-IFuture"><h3>IFuture</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-IPromise"><h3>IPromise</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-IReturn"><h3>IReturn</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-map-future"><h3>map-future</h3><div class="usage"></div><div class="doc"><pre class="plaintext">`f` needs to return a future. Maps `f` over `vs` and sequences all resulting futures. See `sequence`
</pre></div></div><div class="public anchor" id="var-Monad"><h3>Monad</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Monad is an abstraction for a context (box, container,
computation) along with the ability to apply a function
that accepts the value without the context and produces
the result in a context. The resulting context may be
different than the starting context. While the main idea
with functors and applicatives is modifying the values
inside the context, monad is more oriented towards modifying
the context.  Every Monad should also implement
Applicative and Functor protocols, although this can not be
automatically forced by Clojure compiler.

You create a new monad type by extending the Monad protocol
and implementing bind and join methods, while observing
monad laws:

1. Left Identity Law: (bind (pure m x) f) =&gt; (g x)

2. Right Identity Law: (bind m (pure m)) =&gt; m

3. Associativity Law:
   (bind (bind m f) g) =&gt; (bind m (fn [x] (bind (f x) g)

Fluokitten&apos;s test library contains macros that generate
tests for monad laws.

The bind and join methods are not intended to be used
directly by the caller, although you should use them directly
from the implementation of this protocol if needed from
other methods.
</pre></div></div><div class="public anchor" id="var-promise"><h3>promise</h3><div class="usage"><code>(promise)</code></div><div class="doc"><pre class="plaintext">Creates a new, unresolved promise.
</pre></div></div><div class="public anchor" id="var-reduce"><h3>reduce</h3><div class="usage"><code>(reduce f seed ms)</code></div><div class="doc"><pre class="plaintext">Returns a Future containing a list of the results yielded by all futures in `ms` further reduced using `f` and `seed`. See `sequence` and `map`
</pre></div></div><div class="public anchor" id="var-sequence"><h3>sequence</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Given a list of futures, returns a future that will eventually contain a list of the results yielded by all futures. If any future fails, returns a Future representing that failure
</pre></div></div><div class="public anchor" id="var-success"><h3>success</h3><div class="usage"><code>(success v)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-try*"><h3>try*</h3><div class="usage"><code>(try* f)</code></div><div class="doc"><pre class="plaintext">Wraps `f` in a try/catch. Returns the result of `f` in a `Success` type if successful. Returns a `Failure` containing the exception otherwise.
</pre></div></div><div class="public anchor" id="var-try-future"><h3>try-future</h3><h4 class="type">macro</h4><div class="usage"><code>(try-future &amp; body)</code></div><div class="doc"><pre class="plaintext">Wraps body in a try/catch. If an exception is thrown, returns a Future which yields a Failure containg the exception.
</pre></div></div></div></body></html>